{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Why use this plugin? This plugin is aimed at helping to solve the issue of secret management with GitOps and Argo CD. We wanted to find a simple way to utilize Vault without having to rely on an operator or custom resource definition. This plugin can be used not just for secrets but also for deployments, configMaps or any other Kubernetes resource.","title":"Overview"},{"location":"#why-use-this-plugin","text":"This plugin is aimed at helping to solve the issue of secret management with GitOps and Argo CD. We wanted to find a simple way to utilize Vault without having to rely on an operator or custom resource definition. This plugin can be used not just for secrets but also for deployments, configMaps or any other Kubernetes resource.","title":"Why use this plugin?"},{"location":"0x-1x/","text":"Annotation Changes In order to follow Kubernetes annotations, we have updated the supported annotations Old New avp_path avp.kubernetes.io/path avp_ignore avp.kubernetes.io/ignore kv_version avp.kubernetes.io/kv-version AVP Prefix The AVP prefix is now required for all configurations options not including VAULT environment variables (https://www.vaultproject.io/docs/commands#environment-variables). Removed PATH_PREFIX The PATH_PREFIX environment variable has now been removed and is no longer available. IBM Secrets Manager With the addition of AWS Secrets Manager, we have renamed IBM Secrets Manager backend from secretmanager to ibmsecretsmanager .","title":"v0.x to v1.x"},{"location":"0x-1x/#annotation-changes","text":"In order to follow Kubernetes annotations, we have updated the supported annotations Old New avp_path avp.kubernetes.io/path avp_ignore avp.kubernetes.io/ignore kv_version avp.kubernetes.io/kv-version","title":"Annotation Changes"},{"location":"0x-1x/#avp-prefix","text":"The AVP prefix is now required for all configurations options not including VAULT environment variables (https://www.vaultproject.io/docs/commands#environment-variables).","title":"AVP Prefix"},{"location":"0x-1x/#removed-path_prefix","text":"The PATH_PREFIX environment variable has now been removed and is no longer available.","title":"Removed PATH_PREFIX"},{"location":"0x-1x/#ibm-secrets-manager","text":"With the addition of AWS Secrets Manager, we have renamed IBM Secrets Manager backend from secretmanager to ibmsecretsmanager .","title":"IBM Secrets Manager"},{"location":"backends/","text":"HashiCorp Vault We support AppRole and Github Auth Method for getting secrets from Vault. AppRole Authentication For AppRole Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: approle AVP_ROLE_ID: Your AppRole Role ID AVP_SECRET_ID: Your AppRole Secret ID Vault Token Authentication For Vault Token Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address VAULT_TOKEN: Your Vault token AVP_TYPE: vault AVP_AUTH_TYPE: token This option may be the easiest to test with locally, depending on your Vault setup. Github Authentication For Github Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: github AVP_GITHUB_TOKEN: Your Github Personal Access Token Kubernetes Authentication In order to use Kubernetes Authentication a couple of things are required. Configuring Argo CD You can either use your own Service Account or the default Argo CD service account. To use the default Argo CD service account all you need to do is set automountServiceAccountToken to true in the argocd-repo-server . yaml kind: Deployment apiVersion: apps/v1 metadata: name: argocd-repo-server spec: template: spec: automountServiceAccountToken: true This will put the Service Account token in the default path of /var/run/secrets/kubernetes.io/serviceaccount/token . If you want to use your own Service Account, you would first create the Service Account. kubectl create serviceaccount your-service-account . Note : The service account that you use must have access to the Kubernetes TokenReview API. You can find the Vault documentation on configuring Kubernetes here . And then you will update the argocd-repo-server to use that service account. yaml kind: Deployment apiVersion: apps/v1 metadata: name: argocd-repo-server spec: template: spec: serviceAccount: your-service-account automountServiceAccountToken: true Configuring Kubernetes Use the /config endpoint to configure Vault to talk to Kubernetes. Use kubectl cluster-info to validate the Kubernetes host address and TCP port. For the list of available configuration options, please see the API documentation . $ vault write auth/kubernetes/config \\ token_reviewer_jwt=\"<your service account JWT>\" \\ kubernetes_host=https://192.168.99.100:<your TCP port or blank for 443> \\ kubernetes_ca_cert=@ca.crt And then create a named role: vault write auth/kubernetes/role/argocd \\ bound_service_account_names=your-service-account \\ bound_service_account_namespaces=argocd \\ policies=argocd \\ ttl=1h This role authorizes the \"vault-auth\" service account in the default namespace and it gives it the default policy. You can find the full documentation on configuring Kubernetes Authentication Here . Once Argo CD and Kubernetes are configured, you can then set the required environment variables for the plugin: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: k8s AVP_K8S_MOUNT_PATH: Mount Path of your kubernetes Auth (optional) AVP_K8S_ROLE: Your Kuberetes Auth Role AVP_K8S_TOKEN_PATH: Path to JWT (optional) Examples Path Annotation kind: Secret apiVersion: v1 metadata: name: vault-example annotations: avp.kubernetes.io/path: \"secret/data/database\" type: Opaque data: username: <username> password: <password> Inline Path kind: Secret apiVersion: v1 metadata: name: vault-example type: Opaque data: username: <path:secret/data/database#username> password: <path:secret/data/database#password> Versioned secrets kind: Secret apiVersion: v1 metadata: name: vault-example annotations: avp.kubernetes.io/path: \"secret/data/database\" avp.kubernetes.io/secret-version: \"2\" # 2 is the latest revision in this example type: Opaque data: username: <username> password: <password> username-current: <path:secret/data/database#username#2> # same as <username> password-current: <path:secret/data/database#password#2> # same as <password> username-old: <path:secret/data/database#username#1> password-old: <path:secret/data/database#password#1> Note : Only Vault KV-V2 backends support versioning. Versions specified with a KV-V1 Vault will be ignored and the latest version will be retrieved. IBM Cloud Secrets Manager For IBM Cloud Secret Manager we only support using IAM authentication at this time. Additionally, we only support secrets of type arbitrary , retrieved from a secret group. Since arbitrary secrets are not versioned , any version specified in a placeholder is ignored and the latest version is retrieved. IAM Authentication For IAM Authentication, these are the required parameters: AVP_IBM_INSTANCE_URL or VAULT_ADDR: Your IBM Cloud Secret Manager Endpoint AVP_TYPE: ibmsecretsmanager AVP_IBM_API_KEY: Your IBM Cloud API Key Examples Path Annotation kind: Secret apiVersion: v1 metadata: name: ibm-example annotations: avp.kubernetes.io/path: \"ibmcloud/arbitrary/secrets/groups/123\" # 123 represents your Secret Group ID type: Opaque data: username: <username> password: <password> Inline Path kind: Secret apiVersion: v1 metadata: name: ibm-example type: Opaque data: username: <path:ibmcloud/arbitrary/secrets/groups/123#username> password: <path:ibmcloud/arbitrary/secrets/groups/123#password> AWS Secrets Manager AWS Authentication Refer to the AWS go SDK README for supplying AWS credentials. Supported credentials and the order in which they are loaded are described here . These are the parameters for AWS: AVP_TYPE: awssecretsmanager AWS_REGION: Your AWS Region (Optional: defaults to us-east-2) Examples Path Annotation apiVersion: v1 kind: Secret metadata: name: aws-example annotations: avp.kubernetes.io/path: \"test-aws-secret\" # The name of your AWS Secret stringData: sample-secret: <test-secret> type: Opaque Inline Path apiVersion: v1 kind: Secret metadata: name: aws-example stringData: sample-secret: <path:test-aws-secret#test-secret> type: Opaque Versioned secrets apiVersion: v1 kind: Secret metadata: name: aws-example annotations: avp.kubernetes.io/path: \"some-path/secret\" avp.kubernetes.io/secret-version: \"AWSCURRENT\" stringData: sample-secret: <test-secret> sample-secret-again: <path:some-path/secret#test-secret#AWSCURRENT> sample-secret-old: <path:some-path/secret#test-secret#AWSPREVIOUS> type: Opaque GCP Secret Manager GCP Authentication Refer to the Authentication Overview for Google Cloud APIs. These are the parameters for GCP: AVP_TYPE: gcpsecretmanager Examples Path Annotation kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: projects/12345678987/secrets/test-secret type: Opaque data: password: <test-secret> Inline Path kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: password: <path:projects/12345678987/secrets/test-secret#test-secret> Versioned secrets kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: \"projects/12345678987/secrets/test-secret\" avp.kubernetes.io/secret-version: \"latest\" type: Opaque data: current-password: <password> current-password-again: <path:projects/12345678987/secrets/test-secret#password#latest> password-old: <path:projects/12345678987/secrets/test-secret#password#another-version-id> AZURE Key Vault Azure Authentication Refer to the Use environment-based authentication in the Azure SDK for Go. Any secrets that are disabled in the key vault will be skipped if found. For Azure, path is the unique name of your key vault. Note : Versioning is only supported for inline paths. Note : Due to the way the Azure backend works, templates that use inline-path placeholders are more efficient (fewer HTTP calls and therefore lower chance of hitting rate limit) than generic placeholders. These are the parameters for Azure: AVP_TYPE: azurekeyvault Examples Path Annotation kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: \"keyvault\" type: Opaque data: password: <test-secret> Inline Path kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: password: <path:keyvault#test-secret> Versioned secrets kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: current-password: <path:keyvault#password> current-password-again: <path:keyvault#password#8f8da2e06c8240808ee439ff093803b5> password-old: <path:keyvault#password#33740fc26214497f8904d93f20f7db6d>","title":"Backends"},{"location":"backends/#hashicorp-vault","text":"We support AppRole and Github Auth Method for getting secrets from Vault.","title":"HashiCorp Vault"},{"location":"backends/#approle-authentication","text":"For AppRole Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: approle AVP_ROLE_ID: Your AppRole Role ID AVP_SECRET_ID: Your AppRole Secret ID","title":"AppRole Authentication"},{"location":"backends/#vault-token-authentication","text":"For Vault Token Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address VAULT_TOKEN: Your Vault token AVP_TYPE: vault AVP_AUTH_TYPE: token This option may be the easiest to test with locally, depending on your Vault setup.","title":"Vault Token Authentication"},{"location":"backends/#github-authentication","text":"For Github Authentication, these are the required parameters: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: github AVP_GITHUB_TOKEN: Your Github Personal Access Token","title":"Github Authentication"},{"location":"backends/#kubernetes-authentication","text":"In order to use Kubernetes Authentication a couple of things are required. Configuring Argo CD You can either use your own Service Account or the default Argo CD service account. To use the default Argo CD service account all you need to do is set automountServiceAccountToken to true in the argocd-repo-server . yaml kind: Deployment apiVersion: apps/v1 metadata: name: argocd-repo-server spec: template: spec: automountServiceAccountToken: true This will put the Service Account token in the default path of /var/run/secrets/kubernetes.io/serviceaccount/token . If you want to use your own Service Account, you would first create the Service Account. kubectl create serviceaccount your-service-account . Note : The service account that you use must have access to the Kubernetes TokenReview API. You can find the Vault documentation on configuring Kubernetes here . And then you will update the argocd-repo-server to use that service account. yaml kind: Deployment apiVersion: apps/v1 metadata: name: argocd-repo-server spec: template: spec: serviceAccount: your-service-account automountServiceAccountToken: true Configuring Kubernetes Use the /config endpoint to configure Vault to talk to Kubernetes. Use kubectl cluster-info to validate the Kubernetes host address and TCP port. For the list of available configuration options, please see the API documentation . $ vault write auth/kubernetes/config \\ token_reviewer_jwt=\"<your service account JWT>\" \\ kubernetes_host=https://192.168.99.100:<your TCP port or blank for 443> \\ kubernetes_ca_cert=@ca.crt And then create a named role: vault write auth/kubernetes/role/argocd \\ bound_service_account_names=your-service-account \\ bound_service_account_namespaces=argocd \\ policies=argocd \\ ttl=1h This role authorizes the \"vault-auth\" service account in the default namespace and it gives it the default policy. You can find the full documentation on configuring Kubernetes Authentication Here . Once Argo CD and Kubernetes are configured, you can then set the required environment variables for the plugin: VAULT_ADDR: Your HashiCorp Vault Address AVP_TYPE: vault AVP_AUTH_TYPE: k8s AVP_K8S_MOUNT_PATH: Mount Path of your kubernetes Auth (optional) AVP_K8S_ROLE: Your Kuberetes Auth Role AVP_K8S_TOKEN_PATH: Path to JWT (optional)","title":"Kubernetes Authentication"},{"location":"backends/#examples","text":"","title":"Examples"},{"location":"backends/#path-annotation","text":"kind: Secret apiVersion: v1 metadata: name: vault-example annotations: avp.kubernetes.io/path: \"secret/data/database\" type: Opaque data: username: <username> password: <password>","title":"Path Annotation"},{"location":"backends/#inline-path","text":"kind: Secret apiVersion: v1 metadata: name: vault-example type: Opaque data: username: <path:secret/data/database#username> password: <path:secret/data/database#password>","title":"Inline Path"},{"location":"backends/#versioned-secrets","text":"kind: Secret apiVersion: v1 metadata: name: vault-example annotations: avp.kubernetes.io/path: \"secret/data/database\" avp.kubernetes.io/secret-version: \"2\" # 2 is the latest revision in this example type: Opaque data: username: <username> password: <password> username-current: <path:secret/data/database#username#2> # same as <username> password-current: <path:secret/data/database#password#2> # same as <password> username-old: <path:secret/data/database#username#1> password-old: <path:secret/data/database#password#1> Note : Only Vault KV-V2 backends support versioning. Versions specified with a KV-V1 Vault will be ignored and the latest version will be retrieved.","title":"Versioned secrets"},{"location":"backends/#ibm-cloud-secrets-manager","text":"For IBM Cloud Secret Manager we only support using IAM authentication at this time. Additionally, we only support secrets of type arbitrary , retrieved from a secret group. Since arbitrary secrets are not versioned , any version specified in a placeholder is ignored and the latest version is retrieved.","title":"IBM Cloud Secrets Manager"},{"location":"backends/#iam-authentication","text":"For IAM Authentication, these are the required parameters: AVP_IBM_INSTANCE_URL or VAULT_ADDR: Your IBM Cloud Secret Manager Endpoint AVP_TYPE: ibmsecretsmanager AVP_IBM_API_KEY: Your IBM Cloud API Key","title":"IAM Authentication"},{"location":"backends/#examples_1","text":"","title":"Examples"},{"location":"backends/#path-annotation_1","text":"kind: Secret apiVersion: v1 metadata: name: ibm-example annotations: avp.kubernetes.io/path: \"ibmcloud/arbitrary/secrets/groups/123\" # 123 represents your Secret Group ID type: Opaque data: username: <username> password: <password>","title":"Path Annotation"},{"location":"backends/#inline-path_1","text":"kind: Secret apiVersion: v1 metadata: name: ibm-example type: Opaque data: username: <path:ibmcloud/arbitrary/secrets/groups/123#username> password: <path:ibmcloud/arbitrary/secrets/groups/123#password>","title":"Inline Path"},{"location":"backends/#aws-secrets-manager","text":"","title":"AWS Secrets Manager"},{"location":"backends/#aws-authentication","text":"Refer to the AWS go SDK README for supplying AWS credentials. Supported credentials and the order in which they are loaded are described here . These are the parameters for AWS: AVP_TYPE: awssecretsmanager AWS_REGION: Your AWS Region (Optional: defaults to us-east-2)","title":"AWS Authentication"},{"location":"backends/#examples_2","text":"","title":"Examples"},{"location":"backends/#path-annotation_2","text":"apiVersion: v1 kind: Secret metadata: name: aws-example annotations: avp.kubernetes.io/path: \"test-aws-secret\" # The name of your AWS Secret stringData: sample-secret: <test-secret> type: Opaque","title":"Path Annotation"},{"location":"backends/#inline-path_2","text":"apiVersion: v1 kind: Secret metadata: name: aws-example stringData: sample-secret: <path:test-aws-secret#test-secret> type: Opaque","title":"Inline Path"},{"location":"backends/#versioned-secrets_1","text":"apiVersion: v1 kind: Secret metadata: name: aws-example annotations: avp.kubernetes.io/path: \"some-path/secret\" avp.kubernetes.io/secret-version: \"AWSCURRENT\" stringData: sample-secret: <test-secret> sample-secret-again: <path:some-path/secret#test-secret#AWSCURRENT> sample-secret-old: <path:some-path/secret#test-secret#AWSPREVIOUS> type: Opaque","title":"Versioned secrets"},{"location":"backends/#gcp-secret-manager","text":"","title":"GCP Secret Manager"},{"location":"backends/#gcp-authentication","text":"Refer to the Authentication Overview for Google Cloud APIs. These are the parameters for GCP: AVP_TYPE: gcpsecretmanager","title":"GCP Authentication"},{"location":"backends/#examples_3","text":"","title":"Examples"},{"location":"backends/#path-annotation_3","text":"kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: projects/12345678987/secrets/test-secret type: Opaque data: password: <test-secret>","title":"Path Annotation"},{"location":"backends/#inline-path_3","text":"kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: password: <path:projects/12345678987/secrets/test-secret#test-secret>","title":"Inline Path"},{"location":"backends/#versioned-secrets_2","text":"kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: \"projects/12345678987/secrets/test-secret\" avp.kubernetes.io/secret-version: \"latest\" type: Opaque data: current-password: <password> current-password-again: <path:projects/12345678987/secrets/test-secret#password#latest> password-old: <path:projects/12345678987/secrets/test-secret#password#another-version-id>","title":"Versioned secrets"},{"location":"backends/#azure-key-vault","text":"","title":"AZURE Key Vault"},{"location":"backends/#azure-authentication","text":"Refer to the Use environment-based authentication in the Azure SDK for Go. Any secrets that are disabled in the key vault will be skipped if found. For Azure, path is the unique name of your key vault. Note : Versioning is only supported for inline paths. Note : Due to the way the Azure backend works, templates that use inline-path placeholders are more efficient (fewer HTTP calls and therefore lower chance of hitting rate limit) than generic placeholders. These are the parameters for Azure: AVP_TYPE: azurekeyvault","title":"Azure Authentication"},{"location":"backends/#examples_4","text":"","title":"Examples"},{"location":"backends/#path-annotation_4","text":"kind: Secret apiVersion: v1 metadata: name: test-secret annotations: avp.kubernetes.io/path: \"keyvault\" type: Opaque data: password: <test-secret>","title":"Path Annotation"},{"location":"backends/#inline-path_4","text":"kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: password: <path:keyvault#test-secret>","title":"Inline Path"},{"location":"backends/#versioned-secrets_3","text":"kind: Secret apiVersion: v1 metadata: name: test-secret type: Opaque data: current-password: <path:keyvault#password> current-password-again: <path:keyvault#password#8f8da2e06c8240808ee439ff093803b5> password-old: <path:keyvault#password#33740fc26214497f8904d93f20f7db6d>","title":"Versioned secrets"},{"location":"config/","text":"There are 3 different ways that parameters can be passed along to argocd-vault-plugin. Kubernetes Secret You can define a Secret in the argocd namespace of your Argo CD cluster with the Vault configuration. The keys of the secret's data / stringData should be the exact names given above, case-sensitive: apiVersion: v1 data: VAULT_ADDR: Zm9v AVP_AUTH_TYPE: Zm9v AVP_GITHUB_TOKEN: Zm9v AVP_TYPE: Zm9v kind: Secret metadata: name: vault-configuration namespace: argocd type: Opaque You can use it like this: argocd-vault-plugin generate /some/path -s vault-configuration . Note : this requires the argocd-repo-server to have a service account token mounted in the standard location. Configuration File The configuration can be given in a file reachable from the plugin, in any Viper supported format (YAML, JSON, etc.). The keys must match the same names used in the the Kubernetes secret: VAULT_ADDR: http://vault AVP_AUTH_TYPE: github AVP_GITHUB_TOKEN: t0ke3n AVP_TYPE: vault You can use it like this: argocd-vault-plugin generate /some/path -c /path/to/config/file.yaml . This can be useful for use-cases not involving Argo CD. Environment Variables The configuration can be set via environment variables, where each key is prefixed by AVP_ : AVP_TYPE=vault # corresponds to TYPE key Make sure that these environment variables are available to the plugin when running it, whether that is in Argo CD or as a CLI tool. Note that any set environment variables take precedence over configuration pulled from a Kubernetes Secret or a file. Full List of Supported Parameters We support all Vault Environment Variables listed here as well as: Name Description Notes AVP_TYPE The type of Vault backend Supported values: vault , ibmsecretsmanager , awssecretsmanager and gcpsecretmanager AVP_KV_VERSION The vault secret engine Supported values: 1 and 2 (defaults to 2). KV_VERSION will be ignored if the avp.kubernetes.io/kv-version annotation is present in a YAML resource. AVP_AUTH_TYPE The type of authentication Supported values: vault: approle, github, k8s, token . Only honored for AVP_TYPE of vault AVP_GITHUB_TOKEN Github token Required with AUTH_TYPE of github AVP_ROLE_ID Vault AppRole Role_ID Required with AUTH_TYPE of approle AVP_SECRET_ID Vault AppRole Secret_ID Required with AUTH_TYPE of approle AVP_K8S_MOUNT_PATH Kuberentes Auth Mount PATH Optional for AUTH_TYPE of k8s defaults to auth/kubernetes AVP_K8S_ROLE Kuberentes Auth Role Required with AUTH_TYPE of k8s AVP_K8S_TOKEN_PATH Path to JWT for Kubernetes Auth Optional for AUTH_TYPE of k8s defaults to /var/run/secrets/kubernetes.io/serviceaccount/token AVP_IBM_API_KEY IBM Cloud IAM API Key Required with TYPE of ibmsecretsmanager AVP_IBM_INSTANCE_URL Endpoint URL for IBM Cloud Secrets Manager instance If absent, fall back to $VAULT_ADDR AWS_REGION AWS Secrets Manager Region Only valid with TYPE awssecretsmanager Full List of Supported Annotation We support several different annotations that can be used inside a kubernetes resource. These annotations will override any corresponding configuration set via Environment Variable or Configuration File. Annotation Description avp.kubernetes.io/path Path to the Vault Secret avp.kubernetes.io/ignore Boolean to tell the plugin whether or not to process the file. Invalid values translate to false avp.kubernetes.io/kv-version Version of the KV Secret Engine avp.kubernetes.io/secret-version Version of the secret to retrieve. Only effective on generic <placeholder> s so avp.kubernetes.io/path is required when this annotation is used avp.kubernetes.io/remove-missing Plugin will not throw error when a key is missing from Vault Secret. Only works on Secret or ConfigMap resources","title":"Configuration"},{"location":"config/#kubernetes-secret","text":"You can define a Secret in the argocd namespace of your Argo CD cluster with the Vault configuration. The keys of the secret's data / stringData should be the exact names given above, case-sensitive: apiVersion: v1 data: VAULT_ADDR: Zm9v AVP_AUTH_TYPE: Zm9v AVP_GITHUB_TOKEN: Zm9v AVP_TYPE: Zm9v kind: Secret metadata: name: vault-configuration namespace: argocd type: Opaque You can use it like this: argocd-vault-plugin generate /some/path -s vault-configuration . Note : this requires the argocd-repo-server to have a service account token mounted in the standard location.","title":"Kubernetes Secret"},{"location":"config/#configuration-file","text":"The configuration can be given in a file reachable from the plugin, in any Viper supported format (YAML, JSON, etc.). The keys must match the same names used in the the Kubernetes secret: VAULT_ADDR: http://vault AVP_AUTH_TYPE: github AVP_GITHUB_TOKEN: t0ke3n AVP_TYPE: vault You can use it like this: argocd-vault-plugin generate /some/path -c /path/to/config/file.yaml . This can be useful for use-cases not involving Argo CD.","title":"Configuration File"},{"location":"config/#environment-variables","text":"The configuration can be set via environment variables, where each key is prefixed by AVP_ : AVP_TYPE=vault # corresponds to TYPE key Make sure that these environment variables are available to the plugin when running it, whether that is in Argo CD or as a CLI tool. Note that any set environment variables take precedence over configuration pulled from a Kubernetes Secret or a file.","title":"Environment Variables"},{"location":"config/#full-list-of-supported-parameters","text":"We support all Vault Environment Variables listed here as well as: Name Description Notes AVP_TYPE The type of Vault backend Supported values: vault , ibmsecretsmanager , awssecretsmanager and gcpsecretmanager AVP_KV_VERSION The vault secret engine Supported values: 1 and 2 (defaults to 2). KV_VERSION will be ignored if the avp.kubernetes.io/kv-version annotation is present in a YAML resource. AVP_AUTH_TYPE The type of authentication Supported values: vault: approle, github, k8s, token . Only honored for AVP_TYPE of vault AVP_GITHUB_TOKEN Github token Required with AUTH_TYPE of github AVP_ROLE_ID Vault AppRole Role_ID Required with AUTH_TYPE of approle AVP_SECRET_ID Vault AppRole Secret_ID Required with AUTH_TYPE of approle AVP_K8S_MOUNT_PATH Kuberentes Auth Mount PATH Optional for AUTH_TYPE of k8s defaults to auth/kubernetes AVP_K8S_ROLE Kuberentes Auth Role Required with AUTH_TYPE of k8s AVP_K8S_TOKEN_PATH Path to JWT for Kubernetes Auth Optional for AUTH_TYPE of k8s defaults to /var/run/secrets/kubernetes.io/serviceaccount/token AVP_IBM_API_KEY IBM Cloud IAM API Key Required with TYPE of ibmsecretsmanager AVP_IBM_INSTANCE_URL Endpoint URL for IBM Cloud Secrets Manager instance If absent, fall back to $VAULT_ADDR AWS_REGION AWS Secrets Manager Region Only valid with TYPE awssecretsmanager","title":"Full List of Supported Parameters"},{"location":"config/#full-list-of-supported-annotation","text":"We support several different annotations that can be used inside a kubernetes resource. These annotations will override any corresponding configuration set via Environment Variable or Configuration File. Annotation Description avp.kubernetes.io/path Path to the Vault Secret avp.kubernetes.io/ignore Boolean to tell the plugin whether or not to process the file. Invalid values translate to false avp.kubernetes.io/kv-version Version of the KV Secret Engine avp.kubernetes.io/secret-version Version of the secret to retrieve. Only effective on generic <placeholder> s so avp.kubernetes.io/path is required when this annotation is used avp.kubernetes.io/remove-missing Plugin will not throw error when a key is missing from Vault Secret. Only works on Secret or ConfigMap resources","title":"Full List of Supported Annotation"},{"location":"howitworks/","text":"Summary The argocd-vault-plugin works by taking a directory of YAML or JSON files that have been templated out using the pattern of <placeholder> where you would want a value from Vault to go. The inside of the <> would be the actual key in Vault. An annotation can be used to specify exactly where the plugin should look for the vault values. The annotation needs to be in the format avp.kubernetes.io/path: \"path/to/secret\" . For example, if you have a secret with the key password-vault-key that you would want to pull from vault, you might have a yaml that looks something like the below code. In this yaml, the plugin will pull the value of the latest version of the secret at path/to/secret/password-vault-key and inject it into the Secret. As YAML: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: password: <password-vault-key> As JSON: { \"kind\": \"Secret\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"example-secret\", \"annotations\": { \"avp.kubernetes.io/path\": \"path/to/secret\" } }, \"type\": \"Opaque\", \"data\": { \"password\": \"<password-vault-key>\" } } And then once the plugin is done doing the substitutions, it outputs the manifest as YAML to standard out to then be applied by Argo CD. The resulting YAML would look like: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: password: cGFzc3dvcmQK # The Value from the key password-vault-key in vault Replacement behavior By default the plugin does not perform any transformation of the secrets in transit. So if you have plain text secrets in Vault, you will need to use the stringData field and if you have a base64 encoded secret in Vault, you will need to use the data field according to the Kubernetes documentation . There are 2 exceptions to this: Placeholders that are in base64 format - see Base64 placeholders for details Modifiers - see Modifiers for details Types of placeholders Generic placeholders The example in the Summary uses a generic placeholder, which is just the name of the key of the secret in the secrets manager you want to inject. All placeholders have to be keys in the same secret in the secrets manager. Valid examples: <placeholder> Specifying the path of a secret The only way to specify the path of a secret for generic placeholders is to use the avp.kubernetes.io/path annotation like this: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" Specifying the version of a secret The only way to specify the version of a secret for generic placeholders is to use the avp.kubernetes.io/secret-version annotation like this: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/secret-version: \"2\" # Requires at least 2 revisions to exist to work Note : This ignored for secret managers that don't allow versioning, meaning the latest version is returned Inline-path placeholders An inline-path placeholder allows you to specify the path, key, and optionally, the version to use for a specific placeholder. This means you can inject values from multiple distinct secrets in your secrets manager into the same YAML. Valid examples: <path:some/path#secret-key> <path:some/path#secret-key#version> If the version is omitted (first example), the latest version of the secret is retrieved. Specifying the path of a secret The only way to specify the path is in the placeholder itself: the string path: followed by the path in your secret manager to the secret. The avp.kubernetes.io/path annotation has no effect on these placeholders. Specifying the version of a secret The only way to specify the version is in the placeholder itself: the string following the last # in the placeholder should be the ID of the version of the secret in your secret manager. The avp.kubernetes.io/secret-version annotation has no effect on these placeholders. Note : This ignored for secret managers that don't allow versioning, meaning the latest version is returned Special behavior Base64 placeholders Some tools like Kustomize secret generator will create Secrets with data fields containing base64 encoded strings from the source files. If you try to use <placeholder> s in the source files, they will be output in a base64 format. The plugin can handle this case by finding any base64 encoded placeholders (either generic or inline-path), replace them, and re-base64 encode the result. For example, given this input: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: # The base64 encoding of postgres://<username>:<password>@<host>:<port>/<database>?sslmode=require POSTGRES_URL: cG9zdGdyZXM6Ly88dXNlcm5hbWU+OjxwYXNzd29yZD5APGhvc3Q+Ojxwb3J0Pi88ZGF0YWJhc2U+P3NzbG1vZGU9cmVxdWlyZQ== and these values for the secrets: username: user password: pass host: host port: 9443 database: my-db the output is: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: # The base64 encoding of postgres://user:pass@host:9443/my-db?sslmode=require POSTGRES_URL: cG9zdGdyZXM6Ly91c2VyOnBhc3NAaG9zdDo5NDQzL215LWRiP3NzbG1vZGU9cmVxdWlyZQ== Automatically ignoring <placeholder> strings The plugin tries to be helpful and will ignore strings in the format <string> if the avp.kubernetes.io/path annotation is missing, and only try to replace inline-path placeholders This can be very useful when using AVP with YAML/JSON that uses <string> 's for other purposes, for example in CRD's with usage information: kind: CustomResourceDefinition apiVersion: v1 metadata: name: some-crd # Notice, no `avp.kuberenetes.io/path` annotation here annotations: {} type: Opaque fieldRef: # So, <KEY> is NOT a placeholder description: 'Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels[''<KEY>'']`, `metadata.annotations[''<KEY>'']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.' # But, THIS is still a placeholder some-credential: <path:somewhere/in/my/vault#credential> Ignoring entire YAML/JSON files The plugin will ignore any given YAML/JSON file outright with the avp.kubernetes.io/ignore annotation set to \"true\" : kind: CustomResourceDefinition apiVersion: v1 metadata: name: some-crd # Notice, `avp.kuberenetes.io/ignore` annotation is set annotations: avp.kuberenetes.io/ignore: \"true\" type: Opaque fieldRef: # So, <KEY> is NOT a placeholder description: 'Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels[''<KEY>'']`, `metadata.annotations[''<KEY>'']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.' # Neither is this some-credential: <path:somewhere/in/my/vault#credential> # Nor this some-credential: <path:somewhere/in/my/vault#credential#version3> Removing keys with missing values By default, AVP will return an error if there is a <placeholder> that has no matching key in the secrets manager. You can override this by using the annotation avp.kubernetes.io/remove-missing . This will remove keys whose values are missing from Vault from the entire YAML. For example, given this input: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/remove-missing: true stringData: username: <username> password: <pass> And this data in the secrets manager: username: user output is: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/remove-missing: true stringData: username: user This only works with generic placeholders. Modifiers base64encode The base64encode modifier allows you to base64 encode a plain-text value retrieved from a secrets manager before injecting it into a Kubernetes secret. Valid examples: <username | base64encode> <path:secrets/data/my-db#username | base64encode> <path:secrets/data/my-db#username#version3 | base64encode> This can be used for both generic and inline-path placeholders. jsonPath The jsonPath modifier allows you use jsonpath to post-process objects or json, retrieved from a secrets manager, before injecting into a Kubernetes manifest. The output is a string. If your desired datatype is not a string, pass the output through jsonParse. See the Kubernetes jsonPath documentation for more detail: https://kubernetes.io/docs/reference/kubectl/jsonpath/ Valid examples: <credentials | jsonPath {.username}> <path:secrets/data/my-db#credentials | jsonPath {.username}{':'}{.password}> <path:secrets/data/my-db#credentials#version3 | jsonPath {.username} | base64encode> <path:secrets/data/my-db#config | jsonPath {.replicas} | jsonParse> jsonParse The jsonParse modifier parses json strings into objects. Valid examples: <credentialsJson | jsonParse> <path:secrets/data/my-db#credentialsJson | jsonParse> <path:secrets/data/my-db#credentialsJson#version3 | jsonParse>","title":"How it Works"},{"location":"howitworks/#summary","text":"The argocd-vault-plugin works by taking a directory of YAML or JSON files that have been templated out using the pattern of <placeholder> where you would want a value from Vault to go. The inside of the <> would be the actual key in Vault. An annotation can be used to specify exactly where the plugin should look for the vault values. The annotation needs to be in the format avp.kubernetes.io/path: \"path/to/secret\" . For example, if you have a secret with the key password-vault-key that you would want to pull from vault, you might have a yaml that looks something like the below code. In this yaml, the plugin will pull the value of the latest version of the secret at path/to/secret/password-vault-key and inject it into the Secret. As YAML: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: password: <password-vault-key> As JSON: { \"kind\": \"Secret\", \"apiVersion\": \"v1\", \"metadata\": { \"name\": \"example-secret\", \"annotations\": { \"avp.kubernetes.io/path\": \"path/to/secret\" } }, \"type\": \"Opaque\", \"data\": { \"password\": \"<password-vault-key>\" } } And then once the plugin is done doing the substitutions, it outputs the manifest as YAML to standard out to then be applied by Argo CD. The resulting YAML would look like: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: password: cGFzc3dvcmQK # The Value from the key password-vault-key in vault","title":"Summary"},{"location":"howitworks/#replacement-behavior","text":"By default the plugin does not perform any transformation of the secrets in transit. So if you have plain text secrets in Vault, you will need to use the stringData field and if you have a base64 encoded secret in Vault, you will need to use the data field according to the Kubernetes documentation . There are 2 exceptions to this: Placeholders that are in base64 format - see Base64 placeholders for details Modifiers - see Modifiers for details","title":"Replacement behavior"},{"location":"howitworks/#types-of-placeholders","text":"","title":"Types of placeholders"},{"location":"howitworks/#generic-placeholders","text":"The example in the Summary uses a generic placeholder, which is just the name of the key of the secret in the secrets manager you want to inject. All placeholders have to be keys in the same secret in the secrets manager. Valid examples: <placeholder>","title":"Generic placeholders"},{"location":"howitworks/#specifying-the-path-of-a-secret","text":"The only way to specify the path of a secret for generic placeholders is to use the avp.kubernetes.io/path annotation like this: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\"","title":"Specifying the path of a secret"},{"location":"howitworks/#specifying-the-version-of-a-secret","text":"The only way to specify the version of a secret for generic placeholders is to use the avp.kubernetes.io/secret-version annotation like this: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/secret-version: \"2\" # Requires at least 2 revisions to exist to work Note : This ignored for secret managers that don't allow versioning, meaning the latest version is returned","title":"Specifying the version of a secret"},{"location":"howitworks/#inline-path-placeholders","text":"An inline-path placeholder allows you to specify the path, key, and optionally, the version to use for a specific placeholder. This means you can inject values from multiple distinct secrets in your secrets manager into the same YAML. Valid examples: <path:some/path#secret-key> <path:some/path#secret-key#version> If the version is omitted (first example), the latest version of the secret is retrieved.","title":"Inline-path placeholders"},{"location":"howitworks/#specifying-the-path-of-a-secret_1","text":"The only way to specify the path is in the placeholder itself: the string path: followed by the path in your secret manager to the secret. The avp.kubernetes.io/path annotation has no effect on these placeholders.","title":"Specifying the path of a secret"},{"location":"howitworks/#specifying-the-version-of-a-secret_1","text":"The only way to specify the version is in the placeholder itself: the string following the last # in the placeholder should be the ID of the version of the secret in your secret manager. The avp.kubernetes.io/secret-version annotation has no effect on these placeholders. Note : This ignored for secret managers that don't allow versioning, meaning the latest version is returned","title":"Specifying the version of a secret"},{"location":"howitworks/#special-behavior","text":"","title":"Special behavior"},{"location":"howitworks/#base64-placeholders","text":"Some tools like Kustomize secret generator will create Secrets with data fields containing base64 encoded strings from the source files. If you try to use <placeholder> s in the source files, they will be output in a base64 format. The plugin can handle this case by finding any base64 encoded placeholders (either generic or inline-path), replace them, and re-base64 encode the result. For example, given this input: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: # The base64 encoding of postgres://<username>:<password>@<host>:<port>/<database>?sslmode=require POSTGRES_URL: cG9zdGdyZXM6Ly88dXNlcm5hbWU+OjxwYXNzd29yZD5APGhvc3Q+Ojxwb3J0Pi88ZGF0YWJhc2U+P3NzbG1vZGU9cmVxdWlyZQ== and these values for the secrets: username: user password: pass host: host port: 9443 database: my-db the output is: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/path: \"path/to/secret\" type: Opaque data: # The base64 encoding of postgres://user:pass@host:9443/my-db?sslmode=require POSTGRES_URL: cG9zdGdyZXM6Ly91c2VyOnBhc3NAaG9zdDo5NDQzL215LWRiP3NzbG1vZGU9cmVxdWlyZQ==","title":"Base64 placeholders"},{"location":"howitworks/#automatically-ignoring-placeholder-strings","text":"The plugin tries to be helpful and will ignore strings in the format <string> if the avp.kubernetes.io/path annotation is missing, and only try to replace inline-path placeholders This can be very useful when using AVP with YAML/JSON that uses <string> 's for other purposes, for example in CRD's with usage information: kind: CustomResourceDefinition apiVersion: v1 metadata: name: some-crd # Notice, no `avp.kuberenetes.io/path` annotation here annotations: {} type: Opaque fieldRef: # So, <KEY> is NOT a placeholder description: 'Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels[''<KEY>'']`, `metadata.annotations[''<KEY>'']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.' # But, THIS is still a placeholder some-credential: <path:somewhere/in/my/vault#credential>","title":"Automatically ignoring &lt;placeholder&gt; strings"},{"location":"howitworks/#ignoring-entire-yamljson-files","text":"The plugin will ignore any given YAML/JSON file outright with the avp.kubernetes.io/ignore annotation set to \"true\" : kind: CustomResourceDefinition apiVersion: v1 metadata: name: some-crd # Notice, `avp.kuberenetes.io/ignore` annotation is set annotations: avp.kuberenetes.io/ignore: \"true\" type: Opaque fieldRef: # So, <KEY> is NOT a placeholder description: 'Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels[''<KEY>'']`, `metadata.annotations[''<KEY>'']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.' # Neither is this some-credential: <path:somewhere/in/my/vault#credential> # Nor this some-credential: <path:somewhere/in/my/vault#credential#version3>","title":"Ignoring entire YAML/JSON files"},{"location":"howitworks/#removing-keys-with-missing-values","text":"By default, AVP will return an error if there is a <placeholder> that has no matching key in the secrets manager. You can override this by using the annotation avp.kubernetes.io/remove-missing . This will remove keys whose values are missing from Vault from the entire YAML. For example, given this input: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/remove-missing: true stringData: username: <username> password: <pass> And this data in the secrets manager: username: user output is: kind: Secret apiVersion: v1 metadata: name: example-secret annotations: avp.kubernetes.io/remove-missing: true stringData: username: user This only works with generic placeholders.","title":"Removing keys with missing values"},{"location":"howitworks/#modifiers","text":"","title":"Modifiers"},{"location":"howitworks/#base64encode","text":"The base64encode modifier allows you to base64 encode a plain-text value retrieved from a secrets manager before injecting it into a Kubernetes secret. Valid examples: <username | base64encode> <path:secrets/data/my-db#username | base64encode> <path:secrets/data/my-db#username#version3 | base64encode> This can be used for both generic and inline-path placeholders.","title":"base64encode"},{"location":"howitworks/#jsonpath","text":"The jsonPath modifier allows you use jsonpath to post-process objects or json, retrieved from a secrets manager, before injecting into a Kubernetes manifest. The output is a string. If your desired datatype is not a string, pass the output through jsonParse. See the Kubernetes jsonPath documentation for more detail: https://kubernetes.io/docs/reference/kubectl/jsonpath/ Valid examples: <credentials | jsonPath {.username}> <path:secrets/data/my-db#credentials | jsonPath {.username}{':'}{.password}> <path:secrets/data/my-db#credentials#version3 | jsonPath {.username} | base64encode> <path:secrets/data/my-db#config | jsonPath {.replicas} | jsonParse>","title":"jsonPath"},{"location":"howitworks/#jsonparse","text":"The jsonParse modifier parses json strings into objects. Valid examples: <credentialsJson | jsonParse> <path:secrets/data/my-db#credentialsJson | jsonParse> <path:secrets/data/my-db#credentialsJson#version3 | jsonParse>","title":"jsonParse"},{"location":"installation/","text":"There are multiple ways to download and install argocd-vault-plugin depending on your use case. On Linux or macOS via Curl curl -Lo argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/{version}/argocd-vault-plugin_{version}_{linux|darwin}_amd64 chmod +x argocd-vault-plugin mv argocd-vault-plugin /usr/local/bin On macOS via Homebrew brew install argocd-vault-plugin Installing in Argo CD In order to use the plugin in Argo CD you can add it to your Argo CD instance as a volume mount or build your own Argo CD image. The Argo CD docs provide information on how to get started https://argoproj.github.io/argo-cd/operator-manual/custom_tools/ . Note : We have provided a Kustomize app that will install Argo CD and configure the plugin here . InitContainer The first technique is to use an init container and a volumeMount to copy a different version of a tool into the repo-server container. containers: - name: argocd-repo-server volumeMounts: - name: custom-tools mountPath: /usr/local/bin/argocd-vault-plugin subPath: argocd-vault-plugin envFrom: - secretRef: name: argocd-vault-plugin-credentials volumes: - name: custom-tools emptyDir: {} initContainers: - name: download-tools image: alpine:3.8 command: [sh, -c] args: - >- wget -O argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/v1.1.1/argocd-vault-plugin_1.1.1_linux_amd64 && chmod +x argocd-vault-plugin && mv argocd-vault-plugin /custom-tools/ volumeMounts: - mountPath: /custom-tools name: custom-tools Custom Image The following example builds an entirely customized repo-server from a Dockerfile, installing extra dependencies that may be needed for generating manifests. FROM argoproj/argocd:latest # Switch to root for the ability to perform install USER root # Install tools needed for your repo-server to retrieve & decrypt secrets, render manifests # (e.g. curl, awscli, gpg, sops) RUN apt-get update && \\ apt-get install -y \\ curl \\ awscli \\ gpg && \\ apt-get clean && \\ rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* # Install the AVP plugin (as root so we can copy to /usr/local/bin) RUN curl -L -o argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/v1.1.1/argocd-vault-plugin_1.1.1_linux_amd64 RUN chmod +x argocd-vault-plugin RUN mv argocd-vault-plugin /usr/local/bin # Switch back to non-root user USER argocd After making the plugin available, you must then register the plugin, documentation can be found at https://argoproj.github.io/argo-cd/user-guide/config-management-plugins/#plugins on how to do that. For this plugin, you would add this: data: configManagementPlugins: |- - name: argocd-vault-plugin generate: command: [\"argocd-vault-plugin\"] args: [\"generate\", \"./\"] You can use ArgoCD Vault Plugin along with other Kubernetes configuration tools (Helm, Kustomize, etc). The general method is to have your configuration tool output YAMLs that are ready to apply to a cluster except for containing <placeholder> s, and then run the plugin on this output to fill in the secrets. See the Usage page for examples.","title":"Installation"},{"location":"installation/#on-linux-or-macos-via-curl","text":"curl -Lo argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/{version}/argocd-vault-plugin_{version}_{linux|darwin}_amd64 chmod +x argocd-vault-plugin mv argocd-vault-plugin /usr/local/bin","title":"On Linux or macOS via Curl"},{"location":"installation/#on-macos-via-homebrew","text":"brew install argocd-vault-plugin","title":"On macOS via Homebrew"},{"location":"installation/#installing-in-argo-cd","text":"In order to use the plugin in Argo CD you can add it to your Argo CD instance as a volume mount or build your own Argo CD image. The Argo CD docs provide information on how to get started https://argoproj.github.io/argo-cd/operator-manual/custom_tools/ . Note : We have provided a Kustomize app that will install Argo CD and configure the plugin here .","title":"Installing in Argo CD"},{"location":"installation/#initcontainer","text":"The first technique is to use an init container and a volumeMount to copy a different version of a tool into the repo-server container. containers: - name: argocd-repo-server volumeMounts: - name: custom-tools mountPath: /usr/local/bin/argocd-vault-plugin subPath: argocd-vault-plugin envFrom: - secretRef: name: argocd-vault-plugin-credentials volumes: - name: custom-tools emptyDir: {} initContainers: - name: download-tools image: alpine:3.8 command: [sh, -c] args: - >- wget -O argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/v1.1.1/argocd-vault-plugin_1.1.1_linux_amd64 && chmod +x argocd-vault-plugin && mv argocd-vault-plugin /custom-tools/ volumeMounts: - mountPath: /custom-tools name: custom-tools","title":"InitContainer"},{"location":"installation/#custom-image","text":"The following example builds an entirely customized repo-server from a Dockerfile, installing extra dependencies that may be needed for generating manifests. FROM argoproj/argocd:latest # Switch to root for the ability to perform install USER root # Install tools needed for your repo-server to retrieve & decrypt secrets, render manifests # (e.g. curl, awscli, gpg, sops) RUN apt-get update && \\ apt-get install -y \\ curl \\ awscli \\ gpg && \\ apt-get clean && \\ rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* # Install the AVP plugin (as root so we can copy to /usr/local/bin) RUN curl -L -o argocd-vault-plugin https://github.com/IBM/argocd-vault-plugin/releases/download/v1.1.1/argocd-vault-plugin_1.1.1_linux_amd64 RUN chmod +x argocd-vault-plugin RUN mv argocd-vault-plugin /usr/local/bin # Switch back to non-root user USER argocd After making the plugin available, you must then register the plugin, documentation can be found at https://argoproj.github.io/argo-cd/user-guide/config-management-plugins/#plugins on how to do that. For this plugin, you would add this: data: configManagementPlugins: |- - name: argocd-vault-plugin generate: command: [\"argocd-vault-plugin\"] args: [\"generate\", \"./\"] You can use ArgoCD Vault Plugin along with other Kubernetes configuration tools (Helm, Kustomize, etc). The general method is to have your configuration tool output YAMLs that are ready to apply to a cluster except for containing <placeholder> s, and then run the plugin on this output to fill in the secrets. See the Usage page for examples.","title":"Custom Image"},{"location":"usage/","text":"Command Line The plugin can be used via the command line or any shell script. Since the plugin outputs yaml to standard out, you can run the generate command and pipe the output to kubectl . argocd-vault-plugin generate ./ | kubectl apply -f - This will pull the values from Vault, replace the placeholders and then apply the yamls to whatever kubernetes cluster you are connected to. You can also read from stdin like so: cat example.yaml | argocd-vault-plugin generate - | kubectl apply -f - Argo CD Before using the plugin in Argo CD you must follow the steps to install the plugin to your Argo CD instance. Once the plugin is installed, you can use it 3 ways. Select your plugin via the UI by selecting New App and then changing Directory at the bottom of the form to be argocd-vault-plugin . Apply a Argo CD Application yaml that has argocd-vault-plugin as the plugin. apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: your-application-name spec: destination: name: '' namespace: default server: 'https://kubernetes.default.svc' source: path: . plugin: name: argocd-vault-plugin repoURL: http://your-repo/ targetRevision: HEAD project: default Or you can pass the config-management-plugin flag to the Argo CD CLI app create command: argocd app create you-app-name --config-management-plugin argocd-vault-plugin With Helm If you want to use Helm along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-helm init: command: [sh, -c] args: [\"helm dependency build\"] generate: command: [\"sh\", \"-c\"] args: [\"helm template $ARGOCD_APP_NAME . | argocd-vault-plugin generate -\"] If you want to use Helm along with argocd-vault-plugin and use additional helm args : configManagementPlugins: | - name: argocd-vault-plugin-helm init: command: [sh, -c] args: [\"helm dependency build\"] generate: command: [\"sh\", \"-c\"] args: [\"helm template $ARGOCD_APP_NAME ${helm_args} . | argocd-vault-plugin generate -\"] Helm args must be defined in the application manifest: source: path: your-app plugin: name: argocd-vault-plugin-helm env: - name: helm_args value: -f values-dev.yaml -f values-dev-tag.yaml With Kustomize If you want to use Kustomize along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-kustomize generate: command: [\"sh\", \"-c\"] args: [\"kustomize build . | argocd-vault-plugin generate -\"] With Jsonnet If you want to use Jsonnet along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-jsonnet generate: command: [\"sh\", \"-c\"] args: [\"jsonnet . | argocd-vault-plugin generate -\"] The plugin will work with both YAML and JSON output from jsonnet. Refreshing values from Secrets Managers If you want to load in a new value from your Secret Manager without making any new code changes you must use the Hard-Refresh concept in Argo CD. This can be done in two ways. You can either use the UI and select the Hard Refresh button which is located within the Refresh Button . You can also use the argocd app diff command passing the --hard-refresh flag. This will run argocd-vault-plugin again and pull in the new values from you Secret Manager and then you can either have Auto Sync setup or Sync manually to apply the new values. Caching the Vault Token The plugin tries to cache the Vault token obtained from logging into Vault on the argocd-repo-server 's container's disk, at ~/.avp/config.json for the duration of the token's lifetime. This of course requires that the container user is able to write to that path. Some environments, like Openshift, will force a random user for containers to run with; therefore this feature will not work, and the plugin will attempt to login to Vault on every run. This can be fixed by ensuring the argocd-repo-server 's container runs with the user argocd .","title":"Usage"},{"location":"usage/#command-line","text":"The plugin can be used via the command line or any shell script. Since the plugin outputs yaml to standard out, you can run the generate command and pipe the output to kubectl . argocd-vault-plugin generate ./ | kubectl apply -f - This will pull the values from Vault, replace the placeholders and then apply the yamls to whatever kubernetes cluster you are connected to. You can also read from stdin like so: cat example.yaml | argocd-vault-plugin generate - | kubectl apply -f -","title":"Command Line"},{"location":"usage/#argo-cd","text":"Before using the plugin in Argo CD you must follow the steps to install the plugin to your Argo CD instance. Once the plugin is installed, you can use it 3 ways. Select your plugin via the UI by selecting New App and then changing Directory at the bottom of the form to be argocd-vault-plugin . Apply a Argo CD Application yaml that has argocd-vault-plugin as the plugin. apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: your-application-name spec: destination: name: '' namespace: default server: 'https://kubernetes.default.svc' source: path: . plugin: name: argocd-vault-plugin repoURL: http://your-repo/ targetRevision: HEAD project: default Or you can pass the config-management-plugin flag to the Argo CD CLI app create command: argocd app create you-app-name --config-management-plugin argocd-vault-plugin","title":"Argo CD"},{"location":"usage/#with-helm","text":"If you want to use Helm along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-helm init: command: [sh, -c] args: [\"helm dependency build\"] generate: command: [\"sh\", \"-c\"] args: [\"helm template $ARGOCD_APP_NAME . | argocd-vault-plugin generate -\"] If you want to use Helm along with argocd-vault-plugin and use additional helm args : configManagementPlugins: | - name: argocd-vault-plugin-helm init: command: [sh, -c] args: [\"helm dependency build\"] generate: command: [\"sh\", \"-c\"] args: [\"helm template $ARGOCD_APP_NAME ${helm_args} . | argocd-vault-plugin generate -\"] Helm args must be defined in the application manifest: source: path: your-app plugin: name: argocd-vault-plugin-helm env: - name: helm_args value: -f values-dev.yaml -f values-dev-tag.yaml","title":"With Helm"},{"location":"usage/#with-kustomize","text":"If you want to use Kustomize along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-kustomize generate: command: [\"sh\", \"-c\"] args: [\"kustomize build . | argocd-vault-plugin generate -\"]","title":"With Kustomize"},{"location":"usage/#with-jsonnet","text":"If you want to use Jsonnet along with argocd-vault-plugin, register a plugin in the argocd-cm ConfigMap like this: configManagementPlugins: | - name: argocd-vault-plugin-jsonnet generate: command: [\"sh\", \"-c\"] args: [\"jsonnet . | argocd-vault-plugin generate -\"] The plugin will work with both YAML and JSON output from jsonnet.","title":"With Jsonnet"},{"location":"usage/#refreshing-values-from-secrets-managers","text":"If you want to load in a new value from your Secret Manager without making any new code changes you must use the Hard-Refresh concept in Argo CD. This can be done in two ways. You can either use the UI and select the Hard Refresh button which is located within the Refresh Button . You can also use the argocd app diff command passing the --hard-refresh flag. This will run argocd-vault-plugin again and pull in the new values from you Secret Manager and then you can either have Auto Sync setup or Sync manually to apply the new values.","title":"Refreshing values from Secrets Managers"},{"location":"usage/#caching-the-vault-token","text":"The plugin tries to cache the Vault token obtained from logging into Vault on the argocd-repo-server 's container's disk, at ~/.avp/config.json for the duration of the token's lifetime. This of course requires that the container user is able to write to that path. Some environments, like Openshift, will force a random user for containers to run with; therefore this feature will not work, and the plugin will attempt to login to Vault on every run. This can be fixed by ensuring the argocd-repo-server 's container runs with the user argocd .","title":"Caching the Vault Token"},{"location":"cmd/avp/","text":"This is a plugin to replace <placeholder>'s with Vault secrets argocd-vault-plugin [flags] Options -h, --help help for version SEE ALSO argocd-vault-plugin generate - Generate manifests from templates with Vault values argocd-vault-plugin version - Print version information","title":"argocd-vault-plugin"},{"location":"cmd/avp/#options","text":"-h, --help help for version","title":"Options"},{"location":"cmd/avp/#see-also","text":"argocd-vault-plugin generate - Generate manifests from templates with Vault values argocd-vault-plugin version - Print version information","title":"SEE ALSO"},{"location":"cmd/generate/","text":"Generate manifests from templates with Vault values argocd-vault-plugin generate PATH [flags] Options -c, --config-path string path to a file containing Vault configuration (YAML, JSON, envfile) to use -h, --help help for generate -s, --secret-name string name of a Kubernetes Secret containing Vault configuration data in the argocd namespace of your ArgoCD host (Only available when used in ArgoCD) SEE ALSO argocd-vault-plugin - replace <placeholder>'s with Vault secrets","title":"argocd-vault-plugin generate"},{"location":"cmd/generate/#options","text":"-c, --config-path string path to a file containing Vault configuration (YAML, JSON, envfile) to use -h, --help help for generate -s, --secret-name string name of a Kubernetes Secret containing Vault configuration data in the argocd namespace of your ArgoCD host (Only available when used in ArgoCD)","title":"Options"},{"location":"cmd/generate/#see-also","text":"argocd-vault-plugin - replace <placeholder>'s with Vault secrets","title":"SEE ALSO"},{"location":"cmd/version/","text":"Print argocd-vault-plugin version information argocd-vault-plugin version [flags] Options -h, --help help for version SEE ALSO argocd-vault-plugin - replace <placeholder>'s with Vault secrets","title":"argocd-vault-plugin version"},{"location":"cmd/version/#options","text":"-h, --help help for version","title":"Options"},{"location":"cmd/version/#see-also","text":"argocd-vault-plugin - replace <placeholder>'s with Vault secrets","title":"SEE ALSO"}]}